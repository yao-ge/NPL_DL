# 1 "npl/bus.npl"
# 1 "<built-in>"
# 1 "<command-line>"
# 1 "/usr/include/stdc-predef.h" 1 3 4
# 1 "<command-line>" 2
# 1 "npl/bus.npl"
# 38 "npl/bus.npl"
# 1 "npl/functions.npl" 1
# 1 "npl/registers.npl" 1
# 1 "npl/structs.npl" 1
# 1 "npl/base_helper.npl" 1
# 42 "npl/base_helper.npl"
struct l2_t {
    fields {
        bit[48] macda;
        bit[48] macsa;
        bit[16] ethertype;
    }
}

struct vlan_t {
    fields {
        bit[3] pcp;
        bit cfi;
        bit[12] vid;
        bit[16] ethertype;
    }
}

struct ipv4_t {
    fields {
        bit[4] version;
        bit[4] hdr_len;
        bit[8] tos;
        bit[16] v4_length;
        bit[16] id;
        bit[3] flags;
        bit[13] frag_offset;
        bit[8] ttl;
        bit[8] protocol;
        bit[16] hdr_checksum;
        bit[32] sip;
        bit[32] dip;
        varbit[512] option;
    }
    header_length_exp : hdr_len*4;
}

struct udp_t {
 fields {
     bit[16] sport;
     bit[16] dport;
     bit[16] length;
     bit[16] checksum;
     bit[16] job_id;
     bit[16] max_worker;
     bit[16] worker_id;
     bit[16] sequence;
     bit[16] exp;
     bit[16] bias;
     bit[16] bias_exp;
 }
}

struct pss_t {
 fields {
  bit[8192] values;
 }
}

struct payload_grp_t {
 fields {
  pss_t pss[2];
 }
}

struct l2_hdr_grp_t {
    fields {
        l2_t l2;
    }
}

struct l3_hdr_grp_t {
    fields {
        ipv4_t ipv4;
    }
}

struct l4_hdr_grp_t {
 fields {
  udp_t udp;
 }
}


struct ingress_pkt_t {
    fields {
        l2_hdr_grp_t l2_hdr;
        l3_hdr_grp_t l3_hdr;
  l4_hdr_grp_t l4_hdr;
  payload_grp_t payload;
    }
}

struct egress_pkt_t {
    fields {
        l2_hdr_grp_t l2_hdr;
        l3_hdr_grp_t l3_hdr;
  l4_hdr_grp_t l4_hdr;
  payload_grp_t payload;
    }
}


packet ingress_pkt_t ingress_pkt;
packet egress_pkt_t egress_pkt;


struct obj_bus_t {
    fields {
        bit[2] port_type_cfg;
        bit[7] port_num;
        bit[8] dst_modid;
        bit[7] dst_port;
    }
}


struct ccbi_t {
    fields {
        bit[128] l2_pbm;
        bit[128] l3_pbm;
    }
}

struct ccbe_t {
    fields {
        bit[7] dst_port;
    }
}

struct control_id_t {
    fields {
        bit[4] otpid_enable;
        bit ts_enable;
    }
}

struct time_bus_t {
    fields {
        bit[16] currenttime;
    }
}

struct egr_obj_bus_t {
    fields {
        bit[8] dst_modid;
        bit[7] dst_port;
        bit[7] ing_port;
        bit[16] ingress_timestamp;
    }
}

struct aux_bus_t {
    fields {
        bit [16] drop_vector;
    }
}

bus obj_bus_t obj_bus;
bus ccbi_t ccbi;
bus ccbe_t ccbe;
bus control_id_t control_id;
bus time_bus_t time_bus;
bus egr_obj_bus_t egr_obj_bus;
bus aux_bus_t egr_aux_bus;



special_function iarb {

    usage_mode_create(in const eindex,
               out bit[4] otpid_enable,
               out bit[1] ts_enable,
               out bit[7] port_num,
               out bit[2] port_type_cfg,
               out bit[16] currenttime
               );

    usage_mode_select(in bit[1] eindex);

}

special_function mmu {

    usage_mode_create(in const eindex,
               in bit[128] l2_pbm,
               in bit[128] l3_pbm,
               out bit[7] dst_port
               );

    usage_mode_select(in bit[1] eindex);

}


special_function edb {

    usage_mode_create(in const eindex,
               in bit[16] drop_vector,
               in bit[8] dst_mod,
               in bit[7] dst_port
               );

    usage_mode_select(in bit[1] eindex);

}

function base_assign_destination() {
    ccbi.l3_pbm = 0;
    ccbe.dst_port = 0;
    ccbi.l2_pbm = 1 << obj_bus.port_num;
}

function base_egress() {
    egr_aux_bus.drop_vector = 0;
    egr_obj_bus.dst_modid = 0;
    egr_obj_bus.dst_port = obj_bus.port_num;
}
# 2 "npl/structs.npl" 2
# 22 "npl/structs.npl"
struct packet_value_t {
 fields {
  bit[8192] value;
 }
}

struct tmp_t {
 fields {
  bit value_1;
  bit[48] value_48;
  bit[32] value_32;
  bit[16] value_16;
  bit[16] set_cast;
  bit[16] diff_exp;
  bit[16] shift;
 }
}

struct index_t {
 fields {
  bit[48] value_48;
  bit[32] value_32;
  bit[16] value_16;
 }
}

struct packet_info_t {
 fields {
  bit[16] job_id;
  bit[16] max_worker;
  bit[16] worker_id;
  bit[16] sequence;
  bit[16] exp;
  bit[16] bias;
  bit[16] bias_exp;
  bit[16] worker_count;
  bit[16] worker_init_bits;
  bit[16] worker_bits;
  bit[16] max_worker_bits;
  bit[16] reset_worker_bits;
  packet_value_t masks;
 }
}






bus packet_info_t packet_info;
bus tmp_t tmp;
bus index_t index;
# 2 "npl/registers.npl" 2





logical_register tuple_t {
 fields {
  bit[32] data_t = 0;
 }
}


logical_register ps_value {
 fields {
  bit[8192] value00 = 0;
  bit[8192] value01 = 0;
  bit[8192] value10 = 0;
  bit[8192] value11 = 0;
  bit[8192] value20 = 0;
  bit[8192] value21 = 0;
  bit[8192] value30 = 0;
  bit[8192] value31 = 0;
 }
}

logical_register ps_exp {
 fields {
  bit[16] value0 = 0;
  bit[16] value1 = 0;
  bit[16] value2 = 0;
  bit[16] value3 = 0;
 }
}

logical_register ps_bias {
 fields {
  bit[16] value0 = 0;
  bit[16] value1 = 0;
  bit[16] value2 = 0;
  bit[16] value3 = 0;
 }
}

logical_register ps_bias_exp {
 fields {
  bit[16] value0 = 0;
  bit[16] value1 = 0;
  bit[16] value2 = 0;
  bit[16] value3 = 0;
 }
}

logical_register ps_worker_init_bits {
 fields {
  bit[16] value0 = 0;
  bit[16] value1 = 0;
  bit[16] value2 = 0;
  bit[16] value3 = 0;
 }
}

logical_register ps_worker_bits {
 fields {
  bit[16] value0 = 0;
  bit[16] value1 = 0;
  bit[16] value2 = 0;
  bit[16] value3 = 0;
 }
}

logical_register ps_worker_count {
 fields {
  bit[16] value0 = 0;
  bit[16] value1 = 0;
  bit[16] value2 = 0;
  bit[16] value3 = 0;
 }
}

logical_register ps_worker_smac {
 fields {
  bit[48] value0 = 0;
  bit[48] value1 = 0;
  bit[48] value2 = 0;
  bit[48] value3 = 0;
 }
}

logical_register ps_worker_sip {
 fields {
  bit[32] value0 = 0;
  bit[32] value1 = 0;
  bit[32] value2 = 0;
  bit[32] value3 = 0;
 }
}

logical_register ps_worker_sport {
 fields {
  bit[16] value0 = 0;
  bit[16] value1 = 0;
  bit[16] value2 = 0;
  bit[16] value3 = 0;
 }
}
# 2 "npl/functions.npl" 2
# 74 "npl/functions.npl"
function do_drop_action() {
 print("do drop action\n");
 tmp.value_1 = 1;
 packet_drop(tmp.value_1, 0x00000001, 0);
 egr_aux_bus.drop_vector = 1;
}

function reset_worker_bits() {
 print("reset worker bits\n");
 ps_worker_bits.value0 =0;
 ps_worker_bits.value1 =0;
 ps_worker_bits.value2 =0;
 ps_worker_bits.value3 =0;
}


function set_bcast() {

 print("set broadcast\n");
 tmp.set_cast = 1;
}

function reset_all() {
 print("reset all\n");
 ps_worker_bits.value0 = 0;
 ps_worker_bits.value1 = 0;
 ps_worker_bits.value2 = 0;
 ps_worker_bits.value3 = 0;
}

function update_all_header() {
 print("update all header\n");
 egress_pkt.l2_hdr = ingress_pkt.l2_hdr;
 egress_pkt.l3_hdr = ingress_pkt.l3_hdr;
 egress_pkt.l4_hdr = ingress_pkt.l4_hdr;
 egress_pkt.l2_hdr.l2.macda = ingress_pkt.l2_hdr.l2.macsa;
 egress_pkt.l2_hdr.l2.macsa = ingress_pkt.l2_hdr.l2.macda;

 egress_pkt.l3_hdr.ipv4.sip = ingress_pkt.l3_hdr.ipv4.dip;
 egress_pkt.l3_hdr.ipv4.dip = ingress_pkt.l3_hdr.ipv4.sip;

 egress_pkt.l4_hdr.udp.dport = ingress_pkt.l4_hdr.udp.sport;
 egress_pkt.l4_hdr.udp.sport = ingress_pkt.l4_hdr.udp.dport;
 print("egress_pkt.l4_hdr.udp.dport:%d, egress_pkt.l4_hdr.udp.sport:%d\n",
   egress_pkt.l4_hdr.udp.dport, egress_pkt.l4_hdr.udp.sport);
}

function save_worker() {
 print("save worker\n");
 index.value_32 = (packet_info.job_id * 4 + packet_info.worker_count - 1);
 if(0x00 == index.value_32){ ps_worker_smac.value0 = ingress_pkt.l2_hdr.l2.macsa; }else if(0x01 == index.value_32){ ps_worker_smac.value1 = ingress_pkt.l2_hdr.l2.macsa; }else if(0x02 == index.value_32){ ps_worker_smac.value2 = ingress_pkt.l2_hdr.l2.macsa; }else if(0x03 == index.value_32){ ps_worker_smac.value3 = ingress_pkt.l2_hdr.l2.macsa; }else{ do_drop_action(); }
 if(0x00 == index.value_32){ ps_worker_sip.value0 = ingress_pkt.l3_hdr.ipv4.sip; }else if(0x01 == index.value_32){ ps_worker_sip.value1 = ingress_pkt.l3_hdr.ipv4.sip; }else if(0x02 == index.value_32){ ps_worker_sip.value2 = ingress_pkt.l3_hdr.ipv4.sip; }else if(0x03 == index.value_32){ ps_worker_sip.value3 = ingress_pkt.l3_hdr.ipv4.sip; }else{ do_drop_action(); }
 if(0x00 == index.value_32){ ps_worker_sport.value0 = ingress_pkt.l4_hdr.udp.sport; }else if(0x01 == index.value_32){ ps_worker_sport.value1 = ingress_pkt.l4_hdr.udp.sport; }else if(0x02 == index.value_32){ ps_worker_sport.value2 = ingress_pkt.l4_hdr.udp.sport; }else if(0x03 == index.value_32){ ps_worker_sport.value3 = ingress_pkt.l4_hdr.udp.sport; }else{ do_drop_action(); }
}

function worker_count_reset() {
 print("worker count reset\n");
 index.value_32 = (packet_info.job_id * 4 + packet_info.sequence % 4);
 if(0x00 == index.value_32){ ps_worker_count.value0 = 0; }else if(0x01 == index.value_32){ ps_worker_count.value1 = 0; }else if(0x02 == index.value_32){ ps_worker_count.value2 = 0; }else if(0x03 == index.value_32){ ps_worker_count.value3 = 0; }else{ do_drop_action(); }
}

function worker_count_add() {
 print("worker count add\n");
 index.value_32 = (packet_info.job_id * 4 + packet_info.sequence % 4);
 if(0x00 == index.value_32){ tmp.value_16 = ps_worker_count.value0; }else if(0x01 == index.value_32){ tmp.value_16 = ps_worker_count.value1; }else if(0x02 == index.value_32){ tmp.value_16 = ps_worker_count.value2; }else if(0x03 == index.value_32){ tmp.value_16 = ps_worker_count.value3; }else{ do_drop_action(); }
 tmp.value_16 = tmp.value_16 + 1;
 if(0x00 == index.value_32){ ps_worker_count.value0 = tmp.value_16; }else if(0x01 == index.value_32){ ps_worker_count.value1 = tmp.value_16; }else if(0x02 == index.value_32){ ps_worker_count.value2 = tmp.value_16; }else if(0x03 == index.value_32){ ps_worker_count.value3 = tmp.value_16; }else{ do_drop_action(); }
 packet_info.worker_count = tmp.value_16;
}

function worker_count_set() {
 print("worker count set\n");
 index.value_32 = (packet_info.job_id * 4 + packet_info.sequence % 4);
 if(0x00 == index.value_32){ ps_worker_count.value0 = packet_info.max_worker; }else if(0x01 == index.value_32){ ps_worker_count.value1 = packet_info.max_worker; }else if(0x02 == index.value_32){ ps_worker_count.value2 = packet_info.max_worker; }else if(0x03 == index.value_32){ ps_worker_count.value3 = packet_info.max_worker; }else{ do_drop_action(); }
 packet_info.worker_count = packet_info.max_worker;
}

function load_init_bits() {
 print("load init bits\n");
 index.value_32 = (packet_info.job_id * 4 + packet_info.sequence % 4);
 if(0x00 == index.value_32){ packet_info.worker_init_bits = ps_worker_init_bits.value0; }else if(0x01 == index.value_32){ packet_info.worker_init_bits = ps_worker_init_bits.value1; }else if(0x02 == index.value_32){ packet_info.worker_init_bits = ps_worker_init_bits.value2; }else if(0x03 == index.value_32){ packet_info.worker_init_bits = ps_worker_init_bits.value3; }else{ do_drop_action(); }

}

function reset_init_bits() {
 print("reset init bits\n");
 index.value_32 = (packet_info.job_id * 4 + packet_info.sequence % 4);
 if(0x00 == index.value_32){ ps_worker_init_bits.value0 = 0; }else if(0x01 == index.value_32){ ps_worker_init_bits.value1 = 0; }else if(0x02 == index.value_32){ ps_worker_init_bits.value2 = 0; }else if(0x03 == index.value_32){ ps_worker_init_bits.value3 = 0; }else{ do_drop_action(); }
}

function set_init_bits() {
 print("set init bits\n");
 index.value_32 = (packet_info.job_id * 4 + packet_info.sequence % 4);
 if(0x00 == index.value_32){ tmp.value_16 = ps_worker_init_bits.value0; }else if(0x01 == index.value_32){ tmp.value_16 = ps_worker_init_bits.value1; }else if(0x02 == index.value_32){ tmp.value_16 = ps_worker_init_bits.value2; }else if(0x03 == index.value_32){ tmp.value_16 = ps_worker_init_bits.value3; }else{ do_drop_action(); }
    tmp.value_16 = tmp.value_16 | (1 << packet_info.worker_id);
 if(0x00 == index.value_32){ ps_worker_init_bits.value0 = tmp.value_16; }else if(0x01 == index.value_32){ ps_worker_init_bits.value1 = tmp.value_16; }else if(0x02 == index.value_32){ ps_worker_init_bits.value2 = tmp.value_16; }else if(0x03 == index.value_32){ ps_worker_init_bits.value3 = tmp.value_16; }else{ do_drop_action(); }
 packet_info.worker_init_bits = tmp.value_16;
}

function reset_bits() {
 print("reset bits\n");
 index.value_32 = (packet_info.job_id * 4 +(packet_info.sequence - 2)% 4);
 if(0x00 == index.value_32){ ps_worker_bits.value0 = 0; }else if(0x01 == index.value_32){ ps_worker_bits.value1 = 0; }else if(0x02 == index.value_32){ ps_worker_bits.value2 = 0; }else if(0x03 == index.value_32){ ps_worker_bits.value3 = 0; }else{ do_drop_action(); }
}

function load_bits() {
 print("load bits\n");
 index.value_32 = (packet_info.job_id * 4 + packet_info.sequence % 4);
 if(0x00 == index.value_32){ packet_info.worker_bits = ps_worker_bits.value0; }else if(0x01 == index.value_32){ packet_info.worker_bits = ps_worker_bits.value1; }else if(0x02 == index.value_32){ packet_info.worker_bits = ps_worker_bits.value2; }else if(0x03 == index.value_32){ packet_info.worker_bits = ps_worker_bits.value3; }else{ do_drop_action(); }
}

function load_reset_bits() {
 print("load reset bits\n");
 index.value_32 = (packet_info.job_id * 4 + packet_info.sequence % 4);
 if(0x00 == index.value_32){ packet_info.reset_worker_bits = ps_worker_bits.value0; }else if(0x01 == index.value_32){ packet_info.reset_worker_bits = ps_worker_bits.value1; }else if(0x02 == index.value_32){ packet_info.reset_worker_bits = ps_worker_bits.value2; }else if(0x03 == index.value_32){ packet_info.reset_worker_bits = ps_worker_bits.value3; }else{ do_drop_action(); }
}

function load_exp() {
 print("load exponent\n");
 index.value_32 = (packet_info.job_id * 4 + packet_info.sequence % 4);
 if(0x00 == index.value_32){ egress_pkt.l4_hdr.udp.exp = ps_exp.value0; }else if(0x01 == index.value_32){ egress_pkt.l4_hdr.udp.exp = ps_exp.value1; }else if(0x02 == index.value_32){ egress_pkt.l4_hdr.udp.exp = ps_exp.value2; }else if(0x03 == index.value_32){ egress_pkt.l4_hdr.udp.exp = ps_exp.value3; }else{ do_drop_action(); }
}

function read_exp() {
 print("read exponent\n");
 index.value_32 = (packet_info.job_id * 4 + packet_info.sequence % 4);
 if(0x00 == index.value_32){ packet_info.exp = ps_exp.value0; }else if(0x01 == index.value_32){ packet_info.exp = ps_exp.value1; }else if(0x02 == index.value_32){ packet_info.exp = ps_exp.value2; }else if(0x03 == index.value_32){ packet_info.exp = ps_exp.value3; }else{ do_drop_action(); }
}

function save_first_exp() {
 print("save first exponent\n");
 index.value_32 = (packet_info.job_id * 4 + packet_info.sequence % 4);
 if(0x00 == index.value_32){ ps_exp.value0 = ingress_pkt.l4_hdr.udp_exp; }else if(0x01 == index.value_32){ ps_exp.value1 = ingress_pkt.l4_hdr.udp_exp; }else if(0x02 == index.value_32){ ps_exp.value2 = ingress_pkt.l4_hdr.udp_exp; }else if(0x03 == index.value_32){ ps_exp.value3 = ingress_pkt.l4_hdr.udp_exp; }else{ do_drop_action(); }
}

function save_exp() {
 print("save exponent\n");
 index.value_32 = (packet_info.job_id * 4 + packet_info.sequence % 4);
 if(0x00 == index.value_32){ tmp.value_16 = ps_exp.value0; }else if(0x01 == index.value_32){ tmp.value_16 = ps_exp.value1; }else if(0x02 == index.value_32){ tmp.value_16 = ps_exp.value2; }else if(0x03 == index.value_32){ tmp.value_16 = ps_exp.value3; }else{ do_drop_action(); }
    if(tmp.value_16 >= ingress_pkt.l4_hdr.udp.exp){
  tmp.value_16 = ingress_pkt.l4_hdr.udp.exp;
 }
 if(0x00 == index.value_32){ ps_exp.value0 = tmp.value_16; }else if(0x01 == index.value_32){ ps_exp.value1 = tmp.value_16; }else if(0x02 == index.value_32){ ps_exp.value2 = tmp.value_16; }else if(0x03 == index.value_32){ ps_exp.value3 = tmp.value_16; }else{ do_drop_action(); }
}

function reset_exp() {
 print("reset exponent\n");
 if(0x00 == index.value_32){ ps_exp.value0 = 0x7fff; }else if(0x01 == index.value_32){ ps_exp.value1 = 0x7fff; }else if(0x02 == index.value_32){ ps_exp.value2 = 0x7fff; }else if(0x03 == index.value_32){ ps_exp.value3 = 0x7fff; }else{ do_drop_action(); }
}

function load_bias_exp() {
 print("load bias exponent\n");
 index.value_32 = (packet_info.job_id * 4 + packet_info.sequence % 4);
 if(0x00 == index.value_32){ egress_pkt.l4_hdr.udp.bias_exp = ps_bias_exp.value0; }else if(0x01 == index.value_32){ egress_pkt.l4_hdr.udp.bias_exp = ps_bias_exp.value1; }else if(0x02 == index.value_32){ egress_pkt.l4_hdr.udp.bias_exp = ps_bias_exp.value2; }else if(0x03 == index.value_32){ egress_pkt.l4_hdr.udp.bias_exp = ps_bias_exp.value3; }else{ do_drop_action(); }
}

function read_bias_exp() {
 print("read bias exponent\n");
 index.value_32 = (packet_info.job_id * 4 + packet_info.sequence % 4);
 if(0x00 == index.value_32){ packet_info.bias_exp = ps_bias_exp.value0; }else if(0x01 == index.value_32){ packet_info.bias_exp = ps_bias_exp.value1; }else if(0x02 == index.value_32){ packet_info.bias_exp = ps_bias_exp.value2; }else if(0x03 == index.value_32){ packet_info.bias_exp = ps_bias_exp.value3; }else{ do_drop_action(); }
}

function save_first_bias_exp() {
 print("save first bias exponent\n");
 index.value_32 = (packet_info.job_id * 4 + packet_info.sequence % 4);
 if(0x00 == index.value_32){ ps_bias_exp.value0 = ingress_pkt.l4_hdr.udp.bias_exp; }else if(0x01 == index.value_32){ ps_bias_exp.value1 = ingress_pkt.l4_hdr.udp.bias_exp; }else if(0x02 == index.value_32){ ps_bias_exp.value2 = ingress_pkt.l4_hdr.udp.bias_exp; }else if(0x03 == index.value_32){ ps_bias_exp.value3 = ingress_pkt.l4_hdr.udp.bias_exp; }else{ do_drop_action(); }
}

function save_bias_exp() {
 print("save bias exponent\n");
 index.value_32 = (packet_info.job_id * 4 + packet_info.sequence % 4);
 if(0x00 == index.value_32){ tmp.value_16 = ps_bias_exp.value0; }else if(0x01 == index.value_32){ tmp.value_16 = ps_bias_exp.value1; }else if(0x02 == index.value_32){ tmp.value_16 = ps_bias_exp.value2; }else if(0x03 == index.value_32){ tmp.value_16 = ps_bias_exp.value3; }else{ do_drop_action(); }
 if(tmp.value_16 > ingress_pkt.l4_hdr.udp.bias_exp){
  tmp.value_16 = ingress_pkt.l4_hdr.udp.bias_exp;
 }
 if(0x00 == index.value_32){ ps_bias_exp.value0 = tmp.value_16; }else if(0x01 == index.value_32){ ps_bias_exp.value1 = tmp.value_16; }else if(0x02 == index.value_32){ ps_bias_exp.value2 = tmp.value_16; }else if(0x03 == index.value_32){ ps_bias_exp.value3 = tmp.value_16; }else{ do_drop_action(); }
}

function reset_bias_exp() {
 print("reset bias exponent\n");
 index.value_32 = (packet_info.job_id * 4 + packet_info.sequence % 4);
 if(0x00 == index.value_32){ ps_bias_exp.value0 = 0x7fff; }else if(0x01 == index.value_32){ ps_bias_exp.value1 = 0x7fff; }else if(0x02 == index.value_32){ ps_bias_exp.value2 = 0x7fff; }else if(0x03 == index.value_32){ ps_bias_exp.value3 = 0x7fff; }else{ do_drop_action(); }
}

function load_bias() {
 print("load bias\n");
 index.value_32 = (packet_info.job_id * 4 + packet_info.sequence % 4);
 if(0x00 == index.value_32){ egress_pkt.l4_hdr.udp.bias = ps_bias.value0; }else if(0x01 == index.value_32){ egress_pkt.l4_hdr.udp.bias = ps_bias.value1; }else if(0x02 == index.value_32){ egress_pkt.l4_hdr.udp.bias = ps_bias.value2; }else if(0x03 == index.value_32){ egress_pkt.l4_hdr.udp.bias = ps_bias.value3; }else{ do_drop_action(); }
}

function save_first_bias() {
 print("save first bias\n");
 index.value_32 = (packet_info.job_id * 4 + packet_info.sequence % 4);
 if(0x00 == index.value_32){ ps_bias.value0 = ingress_pkt.l4_hdr.udp.bias; }else if(0x01 == index.value_32){ ps_bias.value1 = ingress_pkt.l4_hdr.udp.bias; }else if(0x02 == index.value_32){ ps_bias.value2 = ingress_pkt.l4_hdr.udp.bias; }else if(0x03 == index.value_32){ ps_bias.value3 = ingress_pkt.l4_hdr.udp.bias; }else{ do_drop_action(); }
}

function save_bias() {
 print("save bias\n");
 index.value_32 = (packet_info.job_id * 4 + packet_info.sequence % 4);
 read_bias_exp();
 if(0x00 == index.value_32){ tmp.value_16 = ps_bias.value0; }else if(0x01 == index.value_32){ tmp.value_16 = ps_bias.value1; }else if(0x02 == index.value_32){ tmp.value_16 = ps_bias.value2; }else if(0x03 == index.value_32){ tmp.value_16 = ps_bias.value3; }else{ do_drop_action(); }
 if(packet_info.bias_exp >= ingress_pkt.l4_hdr.udp.bias_exp){
  tmp.shift = packet_info.bias_exp - ingress_pkt.l4_hdr.udp.bias_exp;
 }else{
  tmp.shift = ingress_pkt.l4_hdr.udp.bias_exp - packet_info.bias_exp;
 }

 if(0 == tmp.shift){
  tmp.value_16 = tmp.value_16 + ingress_pkt.l4_hdr.udp.bias;
 }else{
  if(packet_info.bias_exp >= ingress_pkt.l4_hdr.udp.bias_exp){
   tmp.value_16 = tmp.value_16 >> tmp.shift + ingress_pkt.l4_hdr.udp.bias;
  }else{
   tmp.value_16 = tmp.value_16 + ingress_pkt.l4_hdr.udp.bias >> tmp.shift;
  }
 }

 if(0x00 == index.value_32){ ps_bias.value0 = tmp.value_16; }else if(0x01 == index.value_32){ ps_bias.value1 = tmp.value_16; }else if(0x02 == index.value_32){ ps_bias.value2 = tmp.value_16; }else if(0x03 == index.value_32){ ps_bias.value3 = tmp.value_16; }else{ do_drop_action(); }
}

function reset_bias() {
 print("reset bias\n");
 index.value_32 = (packet_info.job_id * 4 + packet_info.sequence % 4);
 if(0x00 == index.value_32){ ps_bias.value0 = 0; }else if(0x01 == index.value_32){ ps_bias.value1 = 0; }else if(0x02 == index.value_32){ ps_bias.value2 = 0; }else if(0x03 == index.value_32){ ps_bias.value3 = 0; }else{ do_drop_action(); }
}

function load_value() {
 print("load value\n");
 index.value_32 = (packet_info.job_id * 4 + packet_info.sequence % 4);
 if(0x00 == index.value_32){
  egress_pkt.payload.pss[0].values = ps_value.value00;
  egress_pkt.payload.pss[1].values = ps_value.value01;
 }else if(0x01 == index.value_32){
  egress_pkt.payload.pss[0].values = ps_value.value10;
  egress_pkt.payload.pss[1].values = ps_value.value11;
 }else if(0x02 == index.value_32){
  egress_pkt.payload.pss[0].values = ps_value.value20;
  egress_pkt.payload.pss[1].values = ps_value.value21;
 }else if(0x03 == index.value_32){
  egress_pkt.payload.pss[0].values = ps_value.value30;
  egress_pkt.payload.pss[1].values = ps_value.value31;
 }else{
  do_drop_action();
 }
}

function save_first_value() {
 print("save first value\n");
 index.value_32 = (packet_info.job_id * 4 + packet_info.sequence % 4);
 if(0x00 == index.value_32){
  ps_value.value00 = ps_value.value00 + ingress_pkt.payload.pss[0].values;
  ps_value.value01 = ps_value.value01 + ingress_pkt.payload.pss[1].values;
 }else if(0x01 == index.value_32){
  ps_value.value10 = ps_value.value10 + ingress_pkt.payload.pss[0].values;
  ps_value.value11 = ps_value.value11 + ingress_pkt.payload.pss[1].values;
 }else if(0x02 == index.value_32){
  ps_value.value20 = ps_value.value20 + ingress_pkt.payload.pss[0].values;
  ps_value.value21 = ps_value.value21 + ingress_pkt.payload.pss[1].values;
 }else if(0x03 == index.value_32){
  ps_value.value30 = ps_value.value30 + ingress_pkt.payload.pss[0].values;
  ps_value.value31 = ps_value.value31 + ingress_pkt.payload.pss[1].values;
 }else{
  do_drop_action();
 }
}

function reset_value() {
 print("reset value\n");
 ps_value.value00 = 0;
 ps_value.value01 = 0;
 ps_value.value10 = 0;
 ps_value.value11 = 0;
 ps_value.value20 = 0;
 ps_value.value21 = 0;
 ps_value.value30 = 0;
 ps_value.value31 = 0;
}



function get_max_worker_bits() {
 print("get max worker bits\n");
 packet_info.max_worker_bits = (1 << packet_info.max_worker) - 1;
}


function reset_according_sequence() {
 print("reset according sequence\n");
 load_init_bits();

 if((65530 >= packet_info.sequence) && (0 == packet_info.worker_init_bits)) {

  update_all_header();
 }else if(packet_info.worker_init_bits & (1 << packet_info.worker_id) != 0) {

  do_drop_action();
 }else {

  if(0 == packet_info.worker_init_bits) {
   worker_count_reset();
   set_init_bits();
   worker_count_add();
   save_worker();

   if(packet_info.worker_init_bits != packet_info.max_worker_bits) {
    do_drop_action();
   }else {
    reset_init_bits();
    reset_all();
    update_all_header();
    set_bcast();
   }
  }
 }
}


function do_egress_pkt_modify() {
 egress_pkt.l2_hdr.l2 = ingress_pkt.l2_hdr.l2;
 egress_pkt.l3_hdr.ipv4 = ingress_pkt.l3_hdr.ipv4;
 egress_pkt.l4_hdr.udp = ingress_pkt.l4_hdr.udp;
 egress_pkt.payload = ingress_pkt.payload;
 tmp.value_16 = ingress_pkt.l2_hdr.l2.ethertype;

 if(1 == tmp.set_cast){
  tmp.value_1 = 1;
  egress_pkt.l2_hdr.l2.macsa[40:40] = tmp.value_1;
  egress_pkt.l2_hdr.l2.macda[40:40] = tmp.value_1;
  print("set broadcast1\n");
 }

 if(egress_pkt.l2_hdr.l2._PRESENT) {
  replace_header_field(egress_pkt.l2_hdr.l2.ethertype, tmp.value_16);
 }else{
  replace_header_field(egress_pkt.l2_hdr.l2.ethertype, tmp.value_16);
 }

}

function update_package() {
 update_all_header();
 load_exp();
 load_bias();
 load_bias_exp();
 load_value();
}

function reset_info() {
 reset_exp();
 reset_bias();
 reset_bias_exp();
 reset_value();
 if(packet_info.sequence > (2)){
  load_reset_bits();
  if(packet_info.reset_worker_bits == packet_info.max_worker_bits){
   reset_bits();
  }
 }
}

function do_calculation() {

 get_max_worker_bits();

 if(60000 <= packet_info.sequence) {
  reset_according_sequence();
 }else{
  load_bits();
  if(packet_info.worker_bits == packet_info.max_worker_bits){
   update_package();
  }else if(0 == packet_info.worker_bits){
   reset_info();
  }
 }
}
# 39 "npl/bus.npl" 2






parser_node start {
    root_node : 1;
    next_node ethernet;
}

parser_node ethernet {
  extract_fields(ingress_pkt.l2_hdr.l2);
  switch(latest.ethertype) {
    0x0800:
      next_node ipv4;

    default :
      next_node ingress;
  }
}

parser_node ipv4 {
    extract_fields(ingress_pkt.l3_hdr.ipv4);
    next_node udp;
}

parser_node udp {
 extract_fields(ingress_pkt.l4_hdr.udp);
 packet_info.job_id = ingress_pkt.l4_hdr.udp.job_id;
 packet_info.max_worker = ingress_pkt.l4_hdr.udp.max_worker;
 packet_info.worker_id = ingress_pkt.l4_hdr.udp.worker_id;
 packet_info.sequence = ingress_pkt.l4_hdr.udp.sequence;
 packet_info.exp = ingress_pkt.l4_hdr.udp.exp;
 packet_info.bias = ingress_pkt.l4_hdr.udp.bias;
 packet_info.bias_exp = ingress_pkt.l4_hdr.udp.bias_exp;
 print("job id:%d, max worker:%d, worker id:%d, sequence:%d, exp:%d, bias:%d, bias_exp:%d\n", packet_info.job_id, packet_info.max_worker, packet_info.worker_id, packet_info.sequence, packet_info.exp, packet_info.bias, packet_info.bias_exp);


 next_node payload;
}

parser_node payload {
 extract_fields(ingress_pkt.payload.pss[0]);
 if(1024 < ingress_pkt.l4_hdr.udp.length - 8) {
  next_node payload1;
 }else{
  next_node ingress;
 }
}

parser_node payload1 {
 extract_fields(ingress_pkt.payload.pss[1]);
 next_node ingress;
}
parser_node ingress {
    end_node: 1;
}





program bus_example {



    iarb.usage_mode_create( 0, control_id.otpid_enable, control_id.ts_enable, obj_bus.port_num, obj_bus.port_type_cfg, time_bus.currenttime ); iarb.execute();


    parse_begin(start);

 if(ingress_pkt.l3_hdr.ipv4._PRESENT){
  print("ipv4 present\n");
 }


 do_calculation();



    base_assign_destination();
    mmu.usage_mode_create( 0, ccbi.l2_pbm, ccbi.l3_pbm, ccbe.dst_port ); mmu.execute();


    base_egress();

 do_egress_pkt_modify();


    edb.usage_mode_create( 0, egr_aux_bus.drop_vector, egr_obj_bus.dst_modid, egr_obj_bus.dst_port ); edb.execute();

}

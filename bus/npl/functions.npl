#include "registers.npl"

/*
 * Populate fields in "packet_field_bus"
 */


#define DROP_REASON__ZERO_DA 0x00000002
#define DROP_REASON__ZERO_SA 0x00000001

#define ADD_SUFFIX(name, num) name##num

#define DATA_READ(var_index, var_1, var_2)	\
	if(0x00 == var_index){					\
		var_2 = ADD_SUFFIX(var_1, 0);		\
	}else if(0x01 == var_index){			\
		var_2 = ADD_SUFFIX(var_1, 1);		\
	}else if(0x02 == var_index){			\
		var_2 = ADD_SUFFIX(var_1, 2);		\
	}else if(0x03 == var_index){			\
		var_2 = ADD_SUFFIX(var_1, 3);		\
	}else{									\
		do_drop_action();					\
	}										\


#define DATA_WRITE(var_index, var_1, var_2)	    \
	if(0x00 == var_index){						\
		ADD_SUFFIX(var_2, 0) = var_1;			\
	}else if(0x01 == var_index){				\
		ADD_SUFFIX(var_2, 1) = var_1;			\
	}else if(0x02 == var_index){				\
		ADD_SUFFIX(var_2, 2) = var_1;			\
	}else if(0x03 == var_index){				\
		ADD_SUFFIX(var_2, 3) = var_1;			\
	}else{										\
		do_drop_action();						\
	}											\



function do_drop_action() {
	tmp.value_1 = 1;
	packet_drop(tmp.value_1, DROP_REASON__ZERO_SA, 0);
	egr_aux_bus.drop_vector = 1;
}

function reset_worker_bits() {
	ps_worker_bits.value0 =0;
	ps_worker_bits.value1 =0;
	ps_worker_bits.value2 =0;
	ps_worker_bits.value3 =0;
}


function set_bcast() {
	/* set egress dmac[40:40] = 1 */
	egress_pkt.l2_hdr = ingress_pkt.l2_hdr;
	egress_pkt.l3_hdr = ingress_pkt.l3_hdr;
	egress_pkt.l4_hdr = ingress_pkt.l4_hdr;
	tmp.value_1 = 1;
	print("set broadcast\n");
	egress_pkt.l2_hdr.l2.macsa[40:40] = tmp.value_1;
	egress_pkt.l2_hdr.l2.macda[40:40] = tmp.value_1;
}

function reset_all() {
	ps_worker_bits.value0 = 0;
	ps_worker_bits.value1 = 0;
	ps_worker_bits.value2 = 0;
	ps_worker_bits.value3 = 0;
}

function update_all_header() {
	egress_pkt.l2_hdr = ingress_pkt.l2_hdr;
	egress_pkt.l3_hdr = ingress_pkt.l3_hdr;
	egress_pkt.l4_hdr = ingress_pkt.l4_hdr;
	egress_pkt.l2_hdr.l2.macda = ingress_pkt.l2_hdr.l2.macsa;
	egress_pkt.l2_hdr.l2.macsa = ingress_pkt.l2_hdr.l2.macda;

	egress_pkt.l3_hdr.ipv4.sip = ingress_pkt.l3_hdr.ipv4.dip;
	egress_pkt.l3_hdr.ipv4.dip = ingress_pkt.l3_hdr.ipv4.sip;

	egress_pkt.l4_hdr.udp.dport = ingress_pkt.l4_hdr.udp.sport;
	egress_pkt.l4_hdr.udp.sport = ingress_pkt.l4_hdr.udp.dport;
}

function save_worker() {
	index.value_32 = WORKER_INFO_SAVE_ADDR;
	DATA_WRITE(index.value_32, ingress_pkt.l2_hdr.l2.macsa, ps_worker_smac.value)
	DATA_WRITE(index.value_32, ingress_pkt.l3_hdr.ipv4.sip, ps_worker_sip.value)
	DATA_WRITE(index.value_32, ingress_pkt.l4_hdr.udp.sport, ps_worker_sport.value)
}

function worker_count_reset() {
	index.value_32 = WORKER_COUNT_ADDR;
	DATA_WRITE(index.value_32, 0, ps_worker_count.value)
}

function worker_count_add() {
	index.value_32 = WORKER_COUNT_ADDR;
	DATA_READ(index.value_32, ps_worker_count.value, tmp.value_16)
	print("tmp worker count:%d\n", tmp.value_16);
	tmp.value_16 = tmp.value_16 + 1;
	DATA_WRITE(index.value_32, tmp.value_16, ps_worker_count.value)
	packet_info.worker_count = tmp.value_16;
	print("packet info worker count:%d\n", packet_info.worker_count);
}

function worker_count_set() {
	index.value_32 = WORKER_COUNT_ADDR;
	DATA_WRITE(index.value_32, packet_info.max_worker, ps_worker_count.value)
	packet_info.worker_count = packet_info.max_worker;
}

function load_init_bits() {
	index.value_32 = WORKER_BITS_ADDR;
	//print("index value:%d\n", index.value_32);
	DATA_READ(index.value_32, ps_worker_init_bits.value, \
			packet_info.worker_init_bits)
	//print("packet info worker init bits:%d\n", packet_info.worker_init_bits);
}

function reset_init_bits() {
	index.value_32 = WORKER_BITS_ADDR;
	DATA_WRITE(index.value_32, 0, ps_worker_init_bits.value)
}

function set_init_bits() {
	index.value_32 = WORKER_BITS_ADDR;
	DATA_READ(index.value_32, ps_worker_init_bits.value, tmp.value_16)
	//print("tmp:%d, worker id:%d\n", tmp.value_16, packet_info.worker_id);
    tmp.value_16 = tmp.value_16 | (1 << packet_info.worker_id);
	//print("tmp:%d\n", tmp.value_16);
	DATA_WRITE(index.value_32, tmp.value_16, ps_worker_init_bits.value)
	packet_info.worker_init_bits = tmp.value_16;
}

/* 通过bit位设置worker数量，bit为1的数量即最大worker数 */
function get_max_worker_bits() {
	packet_info.max_worker_bits = (1 << packet_info.max_worker) - 1;
	//print("max worker bit:%d\n", packet_info.max_worker_bits);
}

/* reset初始化部分 */
function reset_according_sequence() {
	load_init_bits();

	update_all_header();
	if((65530 >= packet_info.sequence) && \
			(0 == packet_info.worker_init_bits)) {
		update_all_header();
		print("update all header!\n");
	}else if(packet_info.worker_init_bits \
			& (1 << packet_info.worker_id) != 0) {
		do_drop_action();
		print("do drop action!\n");
	}else {
		print("worker init bits:%d\n", packet_info.worker_init_bits);

		if(0 == packet_info.worker_init_bits) {
			print("worker count reset!\n");
			worker_count_reset();
			set_init_bits();
			worker_count_add();
			save_worker();

			if(packet_info.worker_init_bits != packet_info.max_worker_bits) {
				do_drop_action();
			}else {
				reset_init_bits();
				reset_all();
				update_all_header();
				set_bcast();
			}
		}
	}
}


function do_egress_pkt_modify() {
	egress_pkt.l2_hdr.l2 = ingress_pkt.l2_hdr.l2;
	egress_pkt.l3_hdr.ipv4 = ingress_pkt.l3_hdr.ipv4;
	egress_pkt.l4_hdr.udp = ingress_pkt.l4_hdr.udp;
	egress_pkt.payload = ingress_pkt.payload;
	tmp.value_16 = ingress_pkt.l2_hdr.l2.ethertype;
	tmp.value_1 = 1;
	egress_pkt.l2_hdr.l2.macsa[40:40] = tmp.value_1;
	egress_pkt.l2_hdr.l2.macda[40:40] = tmp.value_1;
	print("set broadcast\n");
	if(egress_pkt.l2_hdr.l2._PRESENT) {
		replace_header_field(egress_pkt.l2_hdr.l2.ethertype, tmp.value_16);
	}else{
		replace_header_field(egress_pkt.l2_hdr.l2.ethertype, tmp.value_16);
	}

}

function do_calculation() {

	get_max_worker_bits();

	if(60000 <= packet_info.sequence) {
		reset_according_sequence();
	}
}

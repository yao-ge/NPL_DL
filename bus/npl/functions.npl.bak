#include "registers.npl"

/*
 * Populate fields in "packet_field_bus"
 */


#define ADD_ZERO(name) name##0
#define ADD_ONE(name) name##1
#define ADD_TWO(name) name##2
#define ADD_THREE(name) name##3


#define ADD_SUFFIX(name, num) name##num

#define DATA_ACTION(var_index, var_1, var_2)	\
	if(0x00 == var_index){						\
		var_1 = ADD_SUFFIX(var_2, 0);			\
	}else if(0x01 == var_index){				\
		var_1 = ADD_SUFFIX(var_2, 1);			\
	}else if(0x02 == var_index){				\
		var_1 = ADD_SUFFIX(var_2, 2);			\
	}else if(0x03 == var_index){				\
		var_1 = ADD_SUFFIX(var_2, 3);			\
	}else{										\
		do_drop_action();						\
	}											\



function do_drop_action() {
	packet_drop(1, DROP_REASON__ZERO_DA, 0);
	egr_aux_bus.drop_vector = 1;
}

function reset_worker_bits() {
	ps_worker_bits.value0 =0;
	ps_worker_bits.value1 =0;
	ps_worker_bits.value2 =0;
	ps_worker_bits.value3 =0;
}


function set_bcast() {
	/* set egress dmac[40:40] = 1 */
	ingress_pkt.l2_hdr.macsa[40:40] = 1;
}

function update_all_header() {
	tmp.value_48 = ingress_pkt.l2_hdr.l2.macda;
	ingress_pkt.l2_hdr.l2.macda = ingress_pkt.l2_hdr.l2.macsa;
	ingress_pkt.l2_hdr.l2.macsa = tmp.value_48;
	ingress_pkt.l3_hdr.ipv4.ttl = ingress_pkt.l3_hdr.ipv4.ttl + 255;

	tmp.value_32 = ingress_pkt.l3_hdr.ipv4.dip;
	ingress_pkt.l3_hdr.ipv4.dip = ingress_pkt.l3_hdr.ipv4.sip;
	ingress_pkt.l3_hdr.ipv4.sip = tmp.value_32;

	tmp.value16 = ingress_pkt.l4_hdr.udp.dport;
	ingress_pkt.l4_hdr.udp.dport = ingress_pkt.l4_hdr.udp.sport;
	ingress_pkt.l4_hdr.udp.sport = tmp.value_16;
}

function save_bias() {
	index.value_32 = WORKER_ADDR;
	if (0x00 == index.value_32){
	    ps_exp.value0 = packet_info.exp;
	}else if(0x01 == index.value_32){
	    ps_exp.value1 = packet_info.exp;
	}else if(0x02 == index.value_32){
	    ps_exp.value2 = packet_info.exp;
	}else if(0x03 == index.value_32){
	    ps_exp.value3 = packet_info.exp;
	}else{
		do_drop_action();
	}
}

function worker_count_add() {
	index.value_32 = WORKER_COUNT_ADDR;
	if(0x00 == index.value_32){
		ps_worker_count.value0 = ps_worker_count.value0 + 1;
		packet_inf.worker_count = ps_worker_count.value0;
	}else if(0x01 == index.value_32){
		ps_worker_count.value1 = ps_worker_count.value1 + 1;
		packet_inf.worker_count = ps_worker_count.value1;
	}else if(0x02 == index.value_32){
		ps_worker_count.value2 = ps_worker_count.value2 + 1;
		packet_inf.worker_count = ps_worker_count.value2;
	}else if(0x03 == index.value_32){
	    ps_worker_count.value3 = ps_worker_count.value3 + 1;
		packet_inf.worker_count = ps_worker_count.value3;
	}else{
		do_drop_action();
	}
}

function worker_count_set() {
	index.value_32 = WORKER_COUNT_ADDR;
	if(0x00 == index.value_32){
		ps_worker_count.value0 = packet_info.max_wroker;
		packet_info.worker_count = ps_worker_count.value0;
	}else if(0x01 == index.value_32){
		ps_worker_count.value1 = packet_info.max_wroker;
		packet_info.worker_count = ps_worker_count.value1;
	}else if(0x02 == index.value_32){
		ps_worker_count.value2 = packet_info.max_wroker;
		packet_info.worker_count = ps_worker_count.value2;
	}else if(0x03 == index.value_32){
		ps_worker_count.value3 = packet_info.max_wroker;
		packet_info.worker_count = ps_worker_count.value3;
	}else{
		do_drop_action();
	}
}

function worker_count_reset() {
	index.value_32 = WORKER_COUNT_ADDR;
	if(0x00 == index.value_32){
		ps_worker_count.value0 = 0;
	}else if(0x01 == index.value_32){
		ps_worker_count.value1 = 0;
	}else if(0x02 == index.value_32){
		ps_worker_count.value2 = 0;
	}else if(0x03 == index.value_32){
		ps_worker_count.value3 = 0;
	}else{
		do_drop_action();
	}
}

function load_bits() {
	index.value_32 = WORKER_BITS_ADDR;
	if(0x00 == index.value_32){
		packet_info.worker_bits = ps_worker_bits.value0;
	}else if(0x01 == index.value_32){
		packet_info.worker_bits = ps_worker_bits.value1;
	}else if(0x02 == index.value_32){
		packet_info.worker_bits = ps_worker_bits.value2;
	}else if(0x03 == index.value_32){
		packet_info.worker_bits = ps_worker_bits.value3;
	}else{
		do_drop_action();
	}
}

function load_reset_bits() {
	index.value_32 = WORKER_BITS_RESET_ADDR;
	if(0x00 == index.value_32){
		packet_info.reset_worker_bits = ps_worker_bits.value0;
	}else if(0x01 == index.value_32){
		packet_info.reset_worker_bits = ps_worker_bits.value1;
	}else if(0x02 == index.value_32){
		packet_info.reset_worker_bits = ps_worker_bits.value2;
	}else if(0x03 == index.value_32){
		packet_info.reset_worker_bits = ps_worker_bits.value3;
	}else{
		do_drop_action();
	}
}

function load_init_bits() {
	index.value_32 = WORKER_BITS_ADDR;
	DATA_ACTION(index.value_32, packet_info.worker_init_bits, ps_worker_init_bits.value)
}

function add_string(){
	ps_worker_bits.value0 = 12;
	print("add string:%d\n", INT_PRINT(ps_worker_bits.value));
}

/* 通过bit位设置worker数量，bit为1的数量即最大worker数 */
function get_max_worker_bits() {
	packet_info.max_worker_bits = (1 << packet_info.max_worker) - 1;
	print("max worker bit:%d\n", packet_info.max_worker_bits);
}


function do_egress_pkt_modify() {
	egress_pkt.l2_hdr = ingress_pkt.l2_hdr;
	egress_pkt.l3_hdr = ingress_pkt.l3_hdr;
	egress_pkt.l4_hdr = ingress_pkt.l4_hdr;
	egress_pkt.payload = ingress_pkt.payload;
}

function do_calculation() {
	get_max_worker_bits();
}
